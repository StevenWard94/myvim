" vim: fo-=oql:foldmarker=\\begin,\\end:foldmethod=marker:foldlevel=0:nospell:
" ------------------------------------------------------------------------------
" Vim bundles configuration file
" Language:       N/A
" Maintainer:     Steven Ward <stevenward94@gmail.com>
" URL:            https://github.com/stevenward94/myvim
" ------------------------------------------------------------------------------

" Setup \begin1
  set nocompatible

  " Load plugins using vim-plug <https://github.com/junegunn/vim-plug>
  call plug#begin('~/.vim/bundle')

  " Support Bundles
  Plug 'jgdavey/tslime.vim'
  Plug 'Shougo/vimproc.vim', { 'do': 'make' }
  Plug 'ervandew/supertab'
  Plug 'benekastah/neomake'
  Plug 'moll/vim-bbye'
  Plug 'nathanaelkane/vim-indent-guides'
  Plug 'vim-scripts/gitignore'
  Plug 'Shougo/neosnippet'
  Plug 'Shougo/neosnippet-snippets'
  Plug 'honza/vim-snippets'
  " source 'support_functions.vim' to support vim-snippets
  if filereadable(expand("~/.vim/bundle/vim-snippets/snippets/support_functions.vim"))
    source ~/.vim/bundle/vim-snippets/snippets/support_functions.vim
  endif
  Plug 'mattn/webapi-vim'
  Plug 'mattn/gist-vim'
  Plug 'luochen1990/rainbow'
  if executable('ctags')
    Plug 'majutsushi/tagbar'
  endif
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-repeat'
  Plug 'jiangmao/auto-pairs'

  " Git
  Plug 'tpope/vim-fugitive'
  Plug 'int3/vim-extradite'
  Plug 'rhysd/conflict-marker.vim'

  " Bars, Panels & Files
  Plug 'scrooloose/nerdtree'
  Plug 'bling/vim-airline'
  Plug 'ctrlpvim/ctrlp.vim'
  Plug 'tacahiroy/ctrlp-funky'

  " Text Manipulation
  Plug 'vim-scripts/Align'
  Plug 'simnalamburt/vim-mundo'
  Plug 'tpope/vim-commentary'
  Plug 'godlygeek/tabular'
  Plug 'michaeljsmith/vim-indent-object'
  Plug 'easymotion/vim-easymotion'

  " Plugin to enable jumping out of vim into tmux
  " NOTE: disabled by default b/c I currently don't have tmux
  "     : use 'plug#load('vim-tmux-navigator') to load manually
  Plug 'christoomey/vim-tmux-navigator', { 'on': [] }

  " Haskell -- these only load when filetype is 'haskell'
  Plug 'neovimhaskell/haskell-vim', { 'for': 'haskell' }
  Plug 'enomsg/vim-haskellConcealPlus', { 'for': 'haskell' }
  Plug 'eagletmt/ghcmod-vim', { 'for': 'haskell' }
  Plug 'eagletmt/neco-ghc', { 'for': 'haskell' }
  Plug 'Twinside/vim-hoogle', { 'for': 'haskell' }
  Plug 'Twinside/vim-haskellFold', { 'for': 'haskell' }
  Plug 'mpickering/hlint-refactor-vim', { 'for': 'haskell' }
  Plug 'travitch/hasksyn', { 'for': 'haskell' }
  Plug 'dag/vim2hs', { 'for': 'haskell' }
  "Plug 'lukerandall/haskellmode-vim', { 'for': 'haskell' }
  Plug 'adinapoli/cumino', { 'for': 'haskell' }
  Plug 'bitc/vim-hdevtools', { 'for': 'haskell' }

  " Python -- only load when filetype is 'python'
  Plug 'klen/python-mode', { 'for': 'python' }
  Plug 'yssource/python.vim', { 'for': 'python' }
  Plug 'python_match.vim', { 'for': 'python' }
  Plug 'pythoncomplete', { 'for': 'python' }

  " Ruby -- only load when filetype is 'ruby'
  Plug 'tpope/vim-rails', { 'for': 'ruby' }
  let g:rubycomplete_buffer_loading = 1

  " Colorschemes
  Plug 'vim-scripts/wombat256.vim'
  Plug 'tomasr/molokai'
  Plug 'vim-scripts/colorful256.vim'
  Plug 'altercation/vim-colors-solarized'

  " Recommended by Stephen Diehl
  Plug 'scrooloose/syntastic'
  Plug 'tomtom/tlib_vim'
  Plug 'MarcWeber/vim-addon-mw-utils'
  Plug 'garbas/vim-snipmate'
  Plug 'scrooloose/nerdcommenter'
  Plug 'Shougo/neocomplete.vim'

  call plug#end()
" \end1

" Plugin-Specific Configurations \begin1

  " Syntastic \begin2
    map <Leader>s :SyntasticToggleMode<CR>

    set statusline+=%#warningmsg#
    set statusline+=%{SyntasticStatuslineFlag()}
    set statusline+=%*

    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 0
    let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 0
  " \end2

  " GHC-Mod \begin2
    function! s:GHCmod_hask() abort
      map <silent> tw :GhcModTypeInsert<CR>
      map <silent> ts :GhcModSplitFunCase<CR>
      map <silent> tq :GhcModType<CR>
      map <silent> te :GhcModTypeClear<CR>
    endfunction
  " \end2

  " SuperTab \begin2
    let g:SuperTabDefaultCompletionType = '<c-x><c-o>'

    if has('gui_running')
      imap <C-Space> <C-r>=SuperTabAlternateCompletion("\<lt>C-x>\<lt>C-o>")<CR>
    else
      if has('unix')
        inoremap <Nul> <C-r>=SuperTabAlternateCompletion("\<lt>C-x>\<lt>C-o>")<CR>
      endif
    endif
  " \end2

  " Neco-GHC \begin2
    function! s:NecoGHC_hask() abort
      let g:haskellmode_completion_ghc = 1
      setlocal omnifunc=necoghc#omnifunc
    endfunction
  " \end2

  " NERDTree \begin2
    map <leader>n :NERDTreeToggle<CR>
  " \end2

  " Tabularize \begin2
    function! s:Tabularize_hask() abort
      let g:haskell_tabular = 1

      vmap a= :Tabularize /=<CR>
      vmap a; :Tabularize /::<CR>
      vmap a- :Tabularize /-><CR>
    endfunction
  " \end2

  " Ctrl-p \begin2
    " binds the ctrl-p 'fuzzy search' panel to <leader>t (in my case ',t')
    map <silent> <leader>t :CtrlP()<CR>
    noremap <leader>b<Space> :CtrlPBuffer<CR>
    let g:ctrlp_custom_ignore = { 'dir': '\v[\/](.git|.cabal-sandbox|.stack-work)$' }
  " \end2

  " Colorscheme Variables \begin2

    " molokai
    if exists('g:molokai_original')
      unlet g:molokai_original
    endif
    if !exists('g:rehash256') || g:rehash256 == 0
      let g:rehash256 = 1
    endif
  " \end2

  " Airline \begin2

    " Use powerline fonts for airline
    if !exists('g:airline_symbols')
      let g:airline_symbols = {}
    endif

    let g:airline_powerline_fonts = 1
    let g:airline_symbols.space = "\ua0"
  " \end2

  " Haskell-Only \begin2
    " This autocmd group configures certain settings for plugins which,
    " are only loaded when filetype=haskell and thus caused problems when attempting to
    " set variables or call functions that are non-existant for other file types
    " The functions called by the autocmds are defined above in the section for the
    " corresponding plugin
    augroup justhask_plugins
      autocmd!
      autocmd FileType haskell :call s:GHCmod_hask()
      autocmd FileType haskell :call s:NecoGHC_hask()
      autocmd FileType haskell :call s:Tabularize_hask()
    augroup END
    " \end2
" \end1

" Helper Functions \begin1

  " function to auto-update vim-plug on vim startup
  function! s:UpdateVimPlug() abort
    let l:plugins = g:plugs
    if !empty(filter(copy(l:plugins), '!isdirectory(v:val.dir)'))
      silent! PlugInstall
      execute "normal q"
    endif
    unlet l:plugins

    silent PlugUpdate
    execute "normal q"
    PlugUpgrade
    execute "normal \<C-c>"
  endfunction
  "autocmd VimEnter * :call s:UpdateVimPlug()



  " use 'H' in vim-plug window to open help docs for plugin under cursor
  function! s:GetPlugHelpDocs() abort
    let l:plug_name = matchstr(getline('.'), '^- \zs\S\+\ze:')
    if has_key(g:plugs, l:plug_name)

      for help_doc in split(globpath(g:plugs[l:plug_name].dir, 'doc/*.txt'), '\n')
        execute 'tabe' help_doc
      endfor
    endif
    unlet l:plug_name
  endfunction

  augroup plug_help
    autocmd!
    autocmd FileType vim-plug
          \ nnoremap <buffer> <silent> <leader>H :call <SID>GetPlugHelpDocs()<CR>
  augroup END



  " use ',gx' to open a plugin's GitHub URL in browser (also works for commits)
  function! s:GoToGitHub() abort
    let l:curline = getline('.')
    let l:sha = matchstr(l:curline, '^ \X*\zs\x\{7}\ze ')
    let l:name = empty(l:sha) ? matchstr(l:curline, '^[-x+] \zs[^:]\+\ze:')
                            \ : getline(search('^- .*:$', 'bn'))[2:-2]

    let l:uri = get(get(g:plugs, l:name, {}), 'uri', '')
    if l:uri !~ 'github.com'
      return
    endif

    let l:github_repo = matchstr(l:uri, '[^:/]*/'.l:name)
    let l:repo_url = empty(l:sha) ? 'https://github.com/' . l:github_repo
                                \ : printf('https://github.com/%s/commit/%s', l:github_repo, l:sha)
    unlet l:curline l:sha l:name l:uri

    call netrw#BrowseX(l:repo_url, 0)
    unlet l:github_repo l:repo_url
  endfunction

  augroup plug_gotoGitHub
    autocmd!
    autocmd FileType vim-plug
          \ nnoremap <buffer> <silent> <leader>gx :call <SID>GoToGitHub()<CR>
  augroup END



  " function to scroll vim-plug preview window
  function! s:PlugScrollPreview(down) abort
    silent! wincmd P
    if &previewwindow
      execute "normal! " a:down ? "\<C-e>" : "\<C-y>"
      wincmd p
    endif
  endfunction

  

  " function to setup additional mappings for use with vim-plug
  function! s:PlugMappings() abort
    nnoremap <buffer> <silent> J :call <SID>PlugScrollPreview(1)<CR>
    nnoremap <buffer> <silent> K :call <SID>PlugScrollPreview(0)<CR>
    nnoremap <buffer> <silent> <C-n> :call search('^  \X*\zs\x')<CR>
    nnoremap <buffer> <silent> <C-p> :call search('^  \X*\zs\x', 'b')<CR>
    nmap <buffer> <silent> <C-j> <C-n>o
    nmap <buffer> <silent> <C-k> <C-p>o
  endfunction

  augroup plug_extraMappings
    autocmd!
    autocmd FileType vim-plug :call s:PlugMappings()
  augroup END
